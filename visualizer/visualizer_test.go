package visualizer

import (
	"context"
	"sync"
	"testing"
	"time"

	"al.go/terminal"
	"al.go/testing/mocks"
)

func Test_handleKeyboard(t *testing.T) {

	scrMock := &mocks.ScreenMock{}

	runningAnimationMock := &AnimationMock{
		CurrentStateFunc: func() AnimationState {
			return AnimationState{
				IsRunning: true,
			}
		},
	}

	pausedAnimationMock := &AnimationMock{
		CurrentStateFunc: func() AnimationState {
			return AnimationState{
				IsRunning: false,
			}
		},
	}

	sig := make(chan Signal)

	tests := []struct {
		name      string
		key       terminal.Key
		signal    Signal
		exit      bool
		animation Animation
	}{
		{
			name:   "Should exit when esc is pressed",
			key:    "Esc",
			exit:   true,
			signal: Pause,
		},
		{
			name:      "Shoud stop a running animation",
			key:       "Enter",
			animation: runningAnimationMock,
			exit:      false,
			signal:    Pause,
		},
		{
			name:      "Should start a paused animation",
			key:       "Enter",
			animation: pausedAnimationMock,
			exit:      false,
			signal:    Start,
		},
	}

	for _, test := range tests {
		visualizer := New(scrMock)
		visualizer.animation = test.animation

		go visualizer.handleKeyboard(&terminal.KeyboardEvent{KeyPressed: test.key}, sig)

		s := <-sig
		if s != test.signal {
			t.Log(test.name)
			t.Errorf("Expected %v signal, got %v", test.signal, s)
		}
		if test.exit != visualizer.exit {
			if test.exit {
				t.Log(test.name)
				t.Errorf("Visualizer should have exited but got: exit %v", visualizer.exit)
			} else {
				t.Errorf("Visualizer should not have exited but got: exit %v", visualizer.exit)
			}
		}
	}
}

//Mocks

// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq
// Ensure, that AnimationMock does implement Animation.
// If this is not the case, regenerate this file with moq.
var _ Animation = &AnimationMock{}

// AnimationMock is a mock implementation of Animation.
//
//     func TestSomethingThatUsesAnimation(t *testing.T) {
//
//         // make and configure a mocked Animation
//         mockedAnimation := &AnimationMock{
//             CurrentStateFunc: func() AnimationState {
// 	               panic("mock out the CurrentState method")
//             },
//             RunFunc: func(ctx context.Context, scr terminal.Screen, ticker *time.Ticker, signal <-chan Signal)  {
// 	               panic("mock out the Run method")
//             },
//         }
//
//         // use mockedAnimation in code that requires Animation
//         // and then make assertions.
//
//     }
type AnimationMock struct {
	// CurrentStateFunc mocks the CurrentState method.
	CurrentStateFunc func() AnimationState

	// RunFunc mocks the Run method.
	RunFunc func(ctx context.Context, scr terminal.Screen, ticker *time.Ticker, signal <-chan Signal)

	// calls tracks calls to the methods.
	calls struct {
		// CurrentState holds details about calls to the CurrentState method.
		CurrentState []struct {
		}
		// Run holds details about calls to the Run method.
		Run []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Scr is the scr argument value.
			Scr terminal.Screen
			// Ticker is the ticker argument value.
			Ticker *time.Ticker
			// Signal is the signal argument value.
			Signal <-chan Signal
		}
	}
	lockCurrentState sync.RWMutex
	lockRun          sync.RWMutex
}

// CurrentState calls CurrentStateFunc.
func (mock *AnimationMock) CurrentState() AnimationState {
	if mock.CurrentStateFunc == nil {
		panic("AnimationMock.CurrentStateFunc: method is nil but Animation.CurrentState was just called")
	}
	callInfo := struct {
	}{}
	mock.lockCurrentState.Lock()
	mock.calls.CurrentState = append(mock.calls.CurrentState, callInfo)
	mock.lockCurrentState.Unlock()
	return mock.CurrentStateFunc()
}

// CurrentStateCalls gets all the calls that were made to CurrentState.
// Check the length with:
//     len(mockedAnimation.CurrentStateCalls())
func (mock *AnimationMock) CurrentStateCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCurrentState.RLock()
	calls = mock.calls.CurrentState
	mock.lockCurrentState.RUnlock()
	return calls
}

// Run calls RunFunc.
func (mock *AnimationMock) Run(ctx context.Context, scr terminal.Screen, ticker *time.Ticker, signal <-chan Signal) {
	if mock.RunFunc == nil {
		panic("AnimationMock.RunFunc: method is nil but Animation.Run was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Scr    terminal.Screen
		Ticker *time.Ticker
		Signal <-chan Signal
	}{
		Ctx:    ctx,
		Scr:    scr,
		Ticker: ticker,
		Signal: signal,
	}
	mock.lockRun.Lock()
	mock.calls.Run = append(mock.calls.Run, callInfo)
	mock.lockRun.Unlock()
	mock.RunFunc(ctx, scr, ticker, signal)
}

// RunCalls gets all the calls that were made to Run.
// Check the length with:
//     len(mockedAnimation.RunCalls())
func (mock *AnimationMock) RunCalls() []struct {
	Ctx    context.Context
	Scr    terminal.Screen
	Ticker *time.Ticker
	Signal <-chan Signal
} {
	var calls []struct {
		Ctx    context.Context
		Scr    terminal.Screen
		Ticker *time.Ticker
		Signal <-chan Signal
	}
	mock.lockRun.RLock()
	calls = mock.calls.Run
	mock.lockRun.RUnlock()
	return calls
}
