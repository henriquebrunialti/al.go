// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"sync"
	"al.go/terminal"
)

// Ensure, that ScreenMock does implement Screen.
// If this is not the case, regenerate this file with moq.
var _ terminal.Screen = &ScreenMock{}

// ScreenMock is a mock implementation of Screen.
//
//     func TestSomethingThatUsesScreen(t *testing.T) {
//
//         // make and configure a mocked Screen
//         mockedScreen := &ScreenMock{
//             ClearFunc: func()  {
// 	               panic("mock out the Clear method")
//             },
//             DrawAtFunc: func(p Point, options DrawningOptions)  {
// 	               panic("mock out the DrawAt method")
//             },
//             InitFunc: func() error {
// 	               panic("mock out the Init method")
//             },
//             ShowFunc: func()  {
// 	               panic("mock out the Show method")
//             },
//             SizeFunc: func() (int, int) {
// 	               panic("mock out the Size method")
//             },
//         }
//
//         // use mockedScreen in code that requires Screen
//         // and then make assertions.
//
//     }
type ScreenMock struct {
	// ClearFunc mocks the Clear method.
	ClearFunc func()

	// DrawAtFunc mocks the DrawAt method.
	DrawAtFunc func(p terminal.Point, options terminal.DrawningOptions)

	// InitFunc mocks the Init method.
	InitFunc func() error

	// ShowFunc mocks the Show method.
	ShowFunc func()

	// SizeFunc mocks the Size method.
	SizeFunc func() (int, int)

	// calls tracks calls to the methods.
	calls struct {
		// Clear holds details about calls to the Clear method.
		Clear []struct {
		}
		// DrawAt holds details about calls to the DrawAt method.
		DrawAt []struct {
			// P is the p argument value.
			P terminal.Point
			// Options is the options argument value.
			Options terminal.DrawningOptions
		}
		// Init holds details about calls to the Init method.
		Init []struct {
		}
		// Show holds details about calls to the Show method.
		Show []struct {
		}
		// Size holds details about calls to the Size method.
		Size []struct {
		}
	}
	lockClear  sync.RWMutex
	lockDrawAt sync.RWMutex
	lockInit   sync.RWMutex
	lockShow   sync.RWMutex
	lockSize   sync.RWMutex
}

// Clear calls ClearFunc.
func (mock *ScreenMock) Clear() {
	if mock.ClearFunc == nil {
		panic("ScreenMock.ClearFunc: method is nil but Screen.Clear was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClear.Lock()
	mock.calls.Clear = append(mock.calls.Clear, callInfo)
	mock.lockClear.Unlock()
	mock.ClearFunc()
}

// ClearCalls gets all the calls that were made to Clear.
// Check the length with:
//     len(mockedScreen.ClearCalls())
func (mock *ScreenMock) ClearCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClear.RLock()
	calls = mock.calls.Clear
	mock.lockClear.RUnlock()
	return calls
}

// DrawAt calls DrawAtFunc.
func (mock *ScreenMock) DrawAt(p terminal.Point, options terminal.DrawningOptions) {
	if mock.DrawAtFunc == nil {
		panic("ScreenMock.DrawAtFunc: method is nil but Screen.DrawAt was just called")
	}
	callInfo := struct {
		P       terminal.Point
		Options terminal.DrawningOptions
	}{
		P:       p,
		Options: options,
	}
	mock.lockDrawAt.Lock()
	mock.calls.DrawAt = append(mock.calls.DrawAt, callInfo)
	mock.lockDrawAt.Unlock()
	mock.DrawAtFunc(p, options)
}

// DrawAtCalls gets all the calls that were made to DrawAt.
// Check the length with:
//     len(mockedScreen.DrawAtCalls())
func (mock *ScreenMock) DrawAtCalls() []struct {
	P       terminal.Point
	Options terminal.DrawningOptions
} {
	var calls []struct {
		P       terminal.Point
		Options terminal.DrawningOptions
	}
	mock.lockDrawAt.RLock()
	calls = mock.calls.DrawAt
	mock.lockDrawAt.RUnlock()
	return calls
}

// Init calls InitFunc.
func (mock *ScreenMock) Init() error {
	if mock.InitFunc == nil {
		panic("ScreenMock.InitFunc: method is nil but Screen.Init was just called")
	}
	callInfo := struct {
	}{}
	mock.lockInit.Lock()
	mock.calls.Init = append(mock.calls.Init, callInfo)
	mock.lockInit.Unlock()
	return mock.InitFunc()
}

// InitCalls gets all the calls that were made to Init.
// Check the length with:
//     len(mockedScreen.InitCalls())
func (mock *ScreenMock) InitCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockInit.RLock()
	calls = mock.calls.Init
	mock.lockInit.RUnlock()
	return calls
}

// Show calls ShowFunc.
func (mock *ScreenMock) Show() {
	if mock.ShowFunc == nil {
		panic("ScreenMock.ShowFunc: method is nil but Screen.Show was just called")
	}
	callInfo := struct {
	}{}
	mock.lockShow.Lock()
	mock.calls.Show = append(mock.calls.Show, callInfo)
	mock.lockShow.Unlock()
	mock.ShowFunc()
}

// ShowCalls gets all the calls that were made to Show.
// Check the length with:
//     len(mockedScreen.ShowCalls())
func (mock *ScreenMock) ShowCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockShow.RLock()
	calls = mock.calls.Show
	mock.lockShow.RUnlock()
	return calls
}

// Size calls SizeFunc.
func (mock *ScreenMock) Size() (int, int) {
	if mock.SizeFunc == nil {
		panic("ScreenMock.SizeFunc: method is nil but Screen.Size was just called")
	}
	callInfo := struct {
	}{}
	mock.lockSize.Lock()
	mock.calls.Size = append(mock.calls.Size, callInfo)
	mock.lockSize.Unlock()
	return mock.SizeFunc()
}

// SizeCalls gets all the calls that were made to Size.
// Check the length with:
//     len(mockedScreen.SizeCalls())
func (mock *ScreenMock) SizeCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockSize.RLock()
	calls = mock.calls.Size
	mock.lockSize.RUnlock()
	return calls
}
